// Copyright Steinwurf ApS 2016.
// Distributed under the "STEINWURF RESEARCH LICENSE 1.0".
// See accompanying file LICENSE.rst or
// http://www.steinwurf.com/licensing

/// @example reed_solomon.cpp
///
/// Simple example showing how to encode and decode a block
/// of memory using a Reed-Solomon codec.

#include <cstdint>
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <iostream>
#include <set>
#include <vector>
#include <string.h>

#include <kodocpp/kodocpp.hpp>

#include "reed_solomon.h"

// Prints out the elements of a vector to the
// screen for debugging purposes
// vector<uint8_t> vector the vector to be printed
void printVectorBytes(std::vector<uint8_t> vector){
    for (std::vector<uint8_t>::const_iterator i = vector.begin(); i != vector.end(); ++i){
        printf("%.2x ", unsigned(*i));
    }
    std::cout << std::endl;
} 

void printVectorChars(std::vector<uint8_t> vector){
    for (std::vector<uint8_t>::const_iterator i = vector.begin(); i != vector.end(); ++i){
        printf("%c", *i);
    }
    std::cout << std::endl;
} 

void printVectorCharsN(std::vector<uint8_t> vector, int N){
    int j=0;
    for (std::vector<uint8_t>::const_iterator i = vector.begin(); i != vector.end(); ++i){
      if( j++ >= N )
        printf("%c", *i);
    }
    std::cout << std::endl;
} 



int demo_main()
{
    // Seed the random number generator to produce different data every time
    srand((uint32_t)time(0));

    // Set the number of symbols and the symbol size
    uint32_t max_symbols = 6;
    uint32_t max_symbol_size = 5;

    // Create encoder/decoder factories that we will use to build the actual
    // encoder and decoder
/*
    kodocpp::encoder_factory encoder_factory(
        kodocpp::codec::reed_solomon,
        kodocpp::field::binary8,
        max_symbols,
        max_symbol_size);
*/

    kodocpp::encoder_factory encoder_factory(
        kodocpp::codec::reed_solomon,
        kodocpp::field::binary8,
        max_symbols,
        max_symbol_size);

    kodocpp::encoder encoder = encoder_factory.build();


    kodocpp::decoder_factory decoder_factory(
        kodocpp::codec::reed_solomon,
        kodocpp::field::binary8,
        max_symbols,
        max_symbol_size);

    kodocpp::decoder decoder = decoder_factory.build();

    // Allocate some storage for a "payload" the payload is what we would
    // eventually send over a network
    std::cout << "Payload size " << encoder.payload_size() << std::endl;;
    std::vector<uint8_t> payload(encoder.payload_size());

    // Allocate input and output data buffers
    std::vector<uint8_t> data_in(encoder.block_size());
    std::cout << "Decoder block  size " << decoder.block_size() << std::endl;;
    std::vector<uint8_t> data_out(decoder.block_size());

    // Fill the input buffer with random data
    std::cout << "Block size = " << encoder.block_size() << std::endl;;


    char a[] = "My name is Mary! I am a member of the local choir at the St Bishop's church";
    char *b;
    b = a;
    std::generate(data_in.begin(), data_in.end(), [&b]{ return *b++; });

    printVectorChars(data_in);
    
    // Set the symbol storage for the encoder and decoder
    encoder.set_const_symbols(data_in.data(), encoder.block_size());
    decoder.set_mutable_symbols(data_out.data(), decoder.block_size());

    // Install a custom trace function for the decoder
/*
    auto callback = [](const std::string& zone, const std::string& data)
    {
        std::set<std::string> filters =
        {
            "decoder_state", "symbol_coefficients_before_read_symbol"
        };

        if (filters.count(zone))
        {
            std::cout << zone << ":" << std::endl;
            std::cout << data << std::endl;
        }
    };
    decoder.set_trace_callback(callback);
*/

    bool DEBUG_MODE = true;
    uint32_t lost_payloads = 0;
    uint32_t received_payloads = 0;

    while (!decoder.is_complete())
    {
        // The encoder will use a certain amount of bytes of the payload buffer
        uint32_t bytes_used = encoder.write_payload(payload.data());
        std::cout << "Payload generated by encoder, bytes used = "
                  << bytes_used << std::endl;
        if(DEBUG_MODE){
            //    printf("%.2d: ", j);
                printVectorBytes(payload);
                printVectorChars(payload);
                printVectorCharsN(payload, 7);
        }
        // Simulate a channel with a 50% loss rate
        if ( (rand() % 2) == 0)
        {
            lost_payloads++;
            continue;
        }

        // Pass the generated packet to the decoder
        received_payloads++;
        decoder.read_payload(payload.data());
        std::cout << "Payload processed by decoder, current rank = "
                  << decoder.rank() << std::endl << std::endl;
    }

    std::cout << "Number of lost payloads: " << lost_payloads << std::endl;
    std::cout << "Number of received payloads: " << received_payloads
              << std::endl;

    // Check if we properly decoded the data
    if (data_in == data_out)
    {
        printVectorChars(data_in);
        std::cout << "Data decoded correctly" << std::endl;
        printVectorChars(data_out);
    }
    else
    {
        std::cout << "Unexpected failure to decode, "
                  << "please file a bug report :)" << std::endl;
    }

    return 0;
}


std::vector< std::vector<uint8_t> > *encode(uint32_t N, uint32_t max_symbols, uint32_t max_symbol_size, 
        kodocpp::field  field_size, char *data_in_char, int data_size) {

    kodocpp::encoder_factory encoder_factory(
        kodocpp::codec::reed_solomon,
        field_size,
        max_symbols,
        max_symbol_size);

    kodocpp::encoder encoder = encoder_factory.build();

    std::cout << "Payload size : " << encoder.payload_size();
    std::vector<uint8_t> payload(encoder.payload_size());
    // Allocate input and output data buffers
    std::vector<uint8_t> data_in(encoder.block_size());

    char *data = data_in_char; 
    uint32_t data_encoded=0;

    std::vector< std::vector<uint8_t>> *encoded_data = new std::vector< std::vector<uint8_t> >();
   
    uint32_t block_size = max_symbols*max_symbol_size;
    while( data_encoded < data_size ) {

       std::vector<uint8_t> encoded_block; 
          std::generate(data_in.begin(), data_in.end(), 
                [&data, &data_encoded,data_size] () ->uint8_t{ 
                      if(data_encoded < data_size) {
                          data_encoded++;
                          return *data++; 
                       }
                          data_encoded++;
                       return 0;
                }

          );

         encoder.set_const_symbols(data_in.data(), encoder.block_size());


      for(int j = 0; j < N; j ++ ) {
          uint32_t bytes_used = encoder.write_payload(payload.data());
          for (std::vector<uint8_t>::const_iterator it = payload.begin(); it != payload.end(); ++it){
               encoded_block.push_back(*it);
          }
          //printVectorBytes(payload);
          encoded_data->push_back(encoded_block);
      }

   }

   std::cout << "max_symbols " << max_symbols << std::endl;
   std::cout << "max_symbol_size " << max_symbol_size << std::endl;
   std::cout << "Total Number of symbols " << encoded_data->size() << std::endl;

   return encoded_data;

}

char *decode(uint32_t N, uint32_t max_symbols, uint32_t max_symbol_size, 
        kodocpp::field  field_size, std::vector< std::vector<uint8_t> > *encoded_data) {

    kodocpp::decoder_factory decoder_factory(
        kodocpp::codec::reed_solomon,
        field_size,
        max_symbols,
        max_symbol_size);

    kodocpp::decoder decoder = decoder_factory.build();

    // Allocate input and output data buffers
    std::vector<uint8_t> data_out(decoder.block_size());

    std::cout << "Reading  Decoded data " << std::endl;
    for(int i=0; i < max_symbols; i++) {
         std::cout << "Reading  symbol " << std::endl;
        decoder.read_payload((*encoded_data)[i].data());
    }

    if( decoder.is_complete() ) {
       std::cout << " Decoded data " << std::endl;

       printVectorChars(data_out);

    }

   return NULL;

}


int main() {
  demo_main();
  exit(0);

    char a[] = " Tip: When you define a named closure, the compiler generates a corresponding function class for it. Every time you call the lambda through its named variable, the compiler instantiates a closure object at the place of call. Therefore, named closures are useful for reusable functionality (factorial, absolute value, etc.), whereas unnamed lambdas are more suitable for inline ad-hoc computations. Unquestionably, the rising popularity of functional programming will make lambdas widely-used in new C++ projects. It’s true that lambdas don’t offer anything you haven’t been able to do before with function objects. However, lambdas are more convenient than function objects because the tedium of writing boilerplate code for every function class (a constructor, data members and an overloaded operator() among the rest) is relegated to compiler. Additionally, lambdas tend to be more efficient because the compiler is able to optimize them more aggressively than it would a user-declared function or class. Finally, lambdas provide a higher level of security because they let you localize (or even hide) functionality from other clients and modules.";

   std::cout << "Encoding.." << std::endl;
   std::vector< std::vector<uint8_t>> *encoded_data = 
         encode(15, 10, 30, kodocpp::field::binary8, a, strlen(a)) ;

   std::cout << "Total Num coded symbols " << encoded_data->size() << std::endl;

   decode(15, 10, 30, kodocpp::field::binary8, encoded_data);

   std::cout << "Total Num coded symbols " << encoded_data->size() << std::endl;



  demo_main();

}
